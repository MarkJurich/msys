# mingwPORT.functions
# Required.  Shell functions used by mingwPORT.

ask()
# usage: ask "User prompt" "Default response" ResponseVar [QueryMark]
#
# Display "User prompt", then wait for user's response, assigning it
# to `ResponseVar'; if user enters nothing, then substitute the default
# assignment `ResponseVar="Default response"'.
#
# If "Default response" is non-null, it is appended to "User prompt",
# generating a prompt of the form `User prompt (Default response)';
# if `QueryMark' is specified, it is appended to the displayed prompt.
{
  echo -n "$1"; [ -n "$2" ] && echo -n " ($2)"; echo -n "$4 "; read $3
  eval '[ -z "$'$3'" ] && '$3'=$2 || '$3'=`eval echo "$'$3'"`'
}

isyes()
# usage: isyes $variable
#
# Test the value stored in $variable for a case insensitive match to
# the string "yes", or any abbreviated form thereof.
{
  case $1 in
    [Yy] | [Yy][Ee] | [Yy][Ee][Ss]) true ;;
    *) false ;;
  esac
}

win32path()
# usage: Win32PathName=`win32path "/MSYS/PathName"`
#
# Determine the native Win32 path name equivalent for the POSIX style
# "/MSYS/PathName";  (CAVEAT:  the specified "/MSYS/PathName" *must*
# reference an existing *directory* on the MSYS or POSIX host).
{
  2>/dev/null cd $1; pwd -W
}

pref()
# usage: pref "OptionallySourcedCommandFile" [OptionalArguments [...]]
#
# Source a `preferential' configuration overlay script, *if* the named
# "OptionallySourcedCommandFile" has been provided.  If the named script
# is not present, then this function silently does nothing.
#
# If any "OptionalArguments" are specified, then they will be available
# as command line arguments, within the scope of execution of the named
# "OptionallySourcedCommandFile".
{
  [ -f "$1" ] && . "$@"
}

perform()
# usage: perform Action OptionalStep
#
# If a file "mingwPORT.OptionalStep" exists, then source it according
# to the designated strategy for the specified Action.  The supported
# Action keywords, and their effects are:
#
#  step    simply source the "mingwPORT.OptionalStep" file.
#
#  action  if the additional file "mingwPORT.beforeOptionalStep" exists,
#          then source it first;  then source "mingwPORT.OptionalStep";
#          finally, if "mingwPORT.afterOptionalStep" exists, source it.
#
# If any "OptionalArguments" are specified, then they will be available
# as command line arguments, within the scope of execution of all files
# sourced by this function call.
{
  [ -f "$mingwPORT.$2" ] && "$@"
}

require()
# usage: require Action RequiredStep
#
# If the file "mingwPORT.RequiredStep" exists, and is readable, then
# this function sources it, exactly analogously to the `perform' function,
# in accordance with identical strategies specified by the Action keyword;
# otherwise, this function causes the mingwPORT to issue an appropriate
# diagnostic message, and abort.
{
  [ -f "$mingwPORT.$2" ] || die $2 "$MSG_ENOENT"
  [ -r "$mingwPORT.$2" ] || die $2 "$MSG_EACCESS"
  "$@"
}

step()
# usage: step ModuleName
#
# Source the file "mingwPORT.ModuleName"; this is the function dispatcher
# invoked when either `perform' or `require' is called with Action = step.
{
  . "$mingwPORT.$@"
}

action()
# usage: action StepWithOptionalWrapperActions
#
# If file "mingwPORT.beforeStepWithOptionalWrapperActions" exists, then
# source it; then source "mingwPORT.StepWithOptionalWrapperActions"; and
# finally, if file "mingwPORT.afterStepWithOptionalWrapperActions" exists,
# source it; this is the function dispatcher invoked when either `perform'
# or `require' is called with Action = action.
{
  pref "$mingwPORT.before$@"
  . "$mingwPORT.$@"
  pref "$mingwPORT.after$@"
}

die()
# usage: die ModuleName "Message Saying Why"
#
# Display a diagnostic message, and cause the mingwPORT to abort; this
# is the function dispatcher invoked by `require', when the specified
# "mingwPORT.ModuleName" file cannot be sourced; it may also be invoked
# directly from any sourced "mingwPORT.ModuleName" file, to diagnose
# any fatal condition.
{
  echo >&2 "$CMD:mingwPORT.$1: $2"
  exit 1
}

# $RCSfile: mingwPORT.functions,v $: end of file: vim: ft=sh
